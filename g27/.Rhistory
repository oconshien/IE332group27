i = 1
print(datecnt)
while (i <= dim(locationSen)[1]){
#print(i)
point <- sortPM(datefromSQL, cityGrid[trunc(locationSen[i,1]/20) + city_grid_radius, trunc(locationSen[i,2]/20) + city_grid_radius])
points <- rbind(points, point)
i <- i + 1
}
#data_tester <- cbind(locationSen, points)
#Run MlClassifier Once then will be able to predict for any pm values
try <- data_label(points, example[montht])
z <- priority_destinations(locationSen, try)
dataframeForStats <- data.frame(try, "x"=locationSen[,1], "y"=locationSen[,2])
bigData <- rbind(bigData, dataframeForStats)
updates <- nearest_sensor_finder(z, locationSen, 0, try)
locationSen <- updates
datefromSQL <- datefromSQL + 60*60
datecnt <- datecnt + 1
}
View(z)
z <- priority_destinations(locationSen, try)
z
try
locationSen
source('~/IE 332/IE332group27/g27/Super Script.R')
#initialization
budget <- 300000
cityGrid <- buildCity(3)
geoRadius <- 15000
#Generated Pm Values
locationSen <- MappedNetwork$best
locationSen <- cbind(locationSen, "moving"= rep(0, length(locationSen[,1])))
timefromSQL <- 1
datefromSQL <- as.POSIXlt("2019-05-06 20:51:50 CET")
montht <- format(datefromSQL,"%B")
points <- NULL
point <- NULL
dataframeForStates <- NULL
bigData <- NULL
datecnt <- 1
OGmap <- locationSen
while(datecnt <= 24*timefromSQL){
points <- NULL
point <- NULL
dataframeForStats <- NULL
i = 1
print(datecnt)
while (i <= dim(locationSen)[1]){
#print(i)
point <- sortPM(datefromSQL, cityGrid[trunc(locationSen[i,1]/20) + city_grid_radius, trunc(locationSen[i,2]/20) + city_grid_radius])
points <- rbind(points, point)
i <- i + 1
}
#data_tester <- cbind(locationSen, points)
#Run MlClassifier Once then will be able to predict for any pm values
try <- data_label(points, example[montht])
z <- priority_destinations(locationSen, try)
dataframeForStats <- data.frame(try, "x"=locationSen[,1], "y"=locationSen[,2])
bigData <- rbind(bigData, dataframeForStats)
updates <- nearest_sensor_finder(z, locationSen, 0, try)
locationSen <- updates
datefromSQL <- datefromSQL + 60*60
datecnt <- datecnt + 1
}
points <- NULL
point <- NULL
dataframeForStats <- NULL
i = 1
print(datecnt)
while (i <= dim(locationSen)[1]){
#print(i)
point <- sortPM(datefromSQL, cityGrid[trunc(locationSen[i,1]/20) + city_grid_radius, trunc(locationSen[i,2]/20) + city_grid_radius])
points <- rbind(points, point)
i <- i + 1
}
#data_tester <- cbind(locationSen, points)
#Run MlClassifier Once then will be able to predict for any pm values
try <- data_label(points, example[montht])
z <- priority_destinations(locationSen, try, 0)
source('~/IE 332/IE332group27/g27/Super Script.R')
z <- priority_destinations(locationSen, try, 0)
dataframeForStats <- data.frame(try, "x"=locationSen[,1], "y"=locationSen[,2])
bigData <- rbind(bigData, dataframeForStats)
updates <- nearest_sensor_finder(z, locationSen, 0, try)
loop_iterate <- 1
print("loop iterate" = loop_iterate)
print("loop iterate", loop_iterate)
print(paste("loop iterate", loop_iterate)))
print(paste("loop iterate", loop_iterate))
source('~/IE 332/IE332group27/g27/Super Script.R')
source('~/IE 332/IE332group27/g27/Super Script.R')
updates <- nearest_sensor_finder(z, locationSen, 0, try)
source('~/IE 332/IE332group27/g27/Super Script.R')
updates <- nearest_sensor_finder(z, locationSen, 0, try)
source('~/IE 332/IE332group27/g27/Super Script.R')
updates <- nearest_sensor_finder(z, locationSen, 0, try)
locationSen
sensors <- locationSen
mobile_sensors <- sensors[which(sensors[,3]==1),]
mobile_sensors
source('~/IE 332/IE332group27/g27/Super Script.R')
updates <- nearest_sensor_finder(z, locationSen, 0, try)
locationSen <- updates
OGmap == locationSen
count((OGmap == locationSen))==F)
count((OGmap == locationSen)==F)
count((OGmap[,1] == locationSen[,1])==F)
count((OGmap[,1] == locationSen[,1]))
source('~/IE 332/IE332group27/g27/Super Script.R')
updates <- nearest_sensor_finder(z, locationSen, 0, try)
source('~/IE 332/IE332group27/g27/Super Script.R')
updates <- nearest_sensor_finder(z, locationSen, 0, try)
source('~/IE 332/IE332group27/g27/Super Script.R')
updates <- nearest_sensor_finder(z, locationSen, 0, try)
updates
count((OGmap[,1] == updates[,1]))
z
locationSen
count(mobile_sensors[,3])
count(mobile_sensors[,3])
z <- priority_destinations(locationSen, try, 0)
count(try)
count(try[,3])
count(try[,4])
source('~/IE 332/IE332group27/g27/Super Script.R')
#data_tester <- cbind(locationSen, points)
#Run MlClassifier Once then will be able to predict for any pm values
try <- data_label(points, example[montht])
z <- priority_destinations(locationSen, try, 0)
dataframeForStats <- data.frame(try, "x"=locationSen[,1], "y"=locationSen[,2])
bigData <- rbind(bigData, dataframeForStats)
updates <- nearest_sensor_finder(z, locationSen, 0, try)
locationSen <- updates
datefromSQL <- datefromSQL + 60*60
datecnt <- datecnt + 1
source('~/IE 332/IE332group27/g27/Super Script.R')
while(datecnt <= 24*timefromSQL){
points <- NULL
point <- NULL
dataframeForStats <- NULL
i = 1
print(datecnt)
while (i <= dim(locationSen)[1]){
#print(i)
point <- sortPM(datefromSQL, cityGrid[trunc(locationSen[i,1]/20) + city_grid_radius, trunc(locationSen[i,2]/20) + city_grid_radius])
points <- rbind(points, point)
i <- i + 1
}
#data_tester <- cbind(locationSen, points)
#Run MlClassifier Once then will be able to predict for any pm values
try <- data_label(points, example[montht])
z <- priority_destinations(locationSen, try, 0)
dataframeForStats <- data.frame(try, "x"=locationSen[,1], "y"=locationSen[,2])
bigData <- rbind(bigData, dataframeForStats)
updates <- nearest_sensor_finder(z, locationSen, 0, try)
locationSen <- updates
datefromSQL <- datefromSQL + 60*60
datecnt <- datecnt + 1
}
locationSen
locationSen == OGmap
plot(best[,1],best[,2], xlim = c(-geoRadius,geoRadius), ylim = c(-geoRadius,geoRadius), pch = 20, xlab = "X", ylab = "Y")
points(best[,1][which(best[,3]==1)],best[,2][which(best[,3]==1)], col = "green",pch = 20)
legend("topleft", legend = c("Fixed", "Mobile"), col = c("Black","Green"), pch = c(20,20), cex = 0.5)
title("Default Sensor Locations")
circle(0,0,geoRadius)
best <- locationSen
#initialization
budget <- 300000
cityGrid <- buildCity(3)
geoRadius <- 15000
city_grid_radius <- geoRadius / 20
MappedNetwork<- SA(budget, cityGrid, geoRadius = 15000, just_values = F)
datefromSQL <- as.POSIXlt("2019-09-06 20:51:50 CET")
montht <- format(datefromSQL,"%B")
points <- NULL
point <- NULL
dataframeForStates <- NULL
bigData <- NULL
datecnt <- 1
OGmap <- locationSen
while(datecnt <= 24*timefromSQL){
points <- NULL
point <- NULL
dataframeForStats <- NULL
i = 1
print(datecnt)
while (i <= dim(locationSen)[1]){
#print(i)
point <- sortPM(datefromSQL, cityGrid[trunc(locationSen[i,1]/20) + city_grid_radius, trunc(locationSen[i,2]/20) + city_grid_radius])
points <- rbind(points, point)
i <- i + 1
}
#data_tester <- cbind(locationSen, points)
#Run MlClassifier Once then will be able to predict for any pm values
try <- data_label(points, example[montht])
z <- priority_destinations(locationSen, try, 0)
dataframeForStats <- data.frame(try, "x"=locationSen[,1], "y"=locationSen[,2])
bigData <- rbind(bigData, dataframeForStats)
updates <- nearest_sensor_finder(z, locationSen, 0, try)
locationSen <- updates
datefromSQL <- datefromSQL + 60*60
datecnt <- datecnt + 1
}
best <- locationSen
while(datecnt <= 24*timefromSQL){
points <- NULL
point <- NULL
dataframeForStats <- NULL
i = 1
print(datecnt)
while (i <= dim(locationSen)[1]){
#print(i)
point <- sortPM(datefromSQL, cityGrid[trunc(locationSen[i,1]/20) + city_grid_radius, trunc(locationSen[i,2]/20) + city_grid_radius])
points <- rbind(points, point)
i <- i + 1
}
#data_tester <- cbind(locationSen, points)
#Run MlClassifier Once then will be able to predict for any pm values
try <- data_label(points, example[montht])
z <- priority_destinations(locationSen, try, 0)
dataframeForStats <- data.frame(try, "x"=locationSen[,1], "y"=locationSen[,2])
bigData <- rbind(bigData, dataframeForStats)
updates <- nearest_sensor_finder(z, locationSen, 0, try)
locationSen <- updates
datefromSQL <- datefromSQL + 60*60
datecnt <- datecnt + 1
}
plot(best[,1],best[,2], xlim = c(-geoRadius,geoRadius), ylim = c(-geoRadius,geoRadius), pch = 20, xlab = "X", ylab = "Y")
points(best[,1][which(best[,3]==1)],best[,2][which(best[,3]==1)], col = "green",pch = 20)
legend("topleft", legend = c("Fixed", "Mobile"), col = c("Black","Green"), pch = c(20,20), cex = 0.5)
title("Default Sensor Locations")
circle(0,0,geoRadius)
locationSen
OGmap
OGmap==locationSen
rm(list = ls())
#initialization
budget <- 300000
cityGrid <- buildCity(3)
geoRadius <- 15000
city_grid_radius <- geoRadius / 20
MappedNetwork<- SA(budget, cityGrid, geoRadius = 15000, just_values = F)
source('~/IE 332/IE332group27/g27/Super Script.R')
MappedNetwork<- SA(budget, cityGrid, geoRadius = 15000, just_values = F)
example <- MlClassifier()
#Generated Pm Values
locationSen <- MappedNetwork$best
locationSen <- cbind(locationSen, "moving"= rep(0, length(locationSen[,1])))
timefromSQL <- 1
datefromSQL <- as.POSIXlt("2019-09-06 20:51:50 CET")
montht <- format(datefromSQL,"%B")
points <- NULL
point <- NULL
dataframeForStates <- NULL
bigData <- NULL
datecnt <- 1
OGmap <- locationSen
cityGrid <- buildCity(3)
geoRadius <- 15000
city_grid_radius <- geoRadius / 20
MappedNetwork<- SA(budget, cityGrid, geoRadius = 15000, just_values = F)
example <- MlClassifier()
#Generated Pm Values
locationSen <- MappedNetwork$best
locationSen <- cbind(locationSen, "moving"= rep(0, length(locationSen[,1])))
timefromSQL <- 1
datefromSQL <- as.POSIXlt("2019-09-06 20:51:50 CET")
montht <- format(datefromSQL,"%B")
points <- NULL
point <- NULL
dataframeForStates <- NULL
bigData <- NULL
datecnt <- 1
OGmap <- locationSen
while(datecnt <= 24*timefromSQL){
points <- NULL
point <- NULL
dataframeForStats <- NULL
i = 1
print(datecnt)
while (i <= dim(locationSen)[1]){
#print(i)
point <- sortPM(datefromSQL, cityGrid[trunc(locationSen[i,1]/20) + city_grid_radius, trunc(locationSen[i,2]/20) + city_grid_radius])
points <- rbind(points, point)
i <- i + 1
}
#data_tester <- cbind(locationSen, points)
#Run MlClassifier Once then will be able to predict for any pm values
try <- data_label(points, example[montht])
z <- priority_destinations(locationSen, try, 0)
dataframeForStats <- data.frame(try, "x"=locationSen[,1], "y"=locationSen[,2])
bigData <- rbind(bigData, dataframeForStats)
updates <- nearest_sensor_finder(z, locationSen, 0, try)
locationSen <- updates
datefromSQL <- datefromSQL + 60*60
datecnt <- datecnt + 1
}
storm_time <- sample(c(0,1), prob = c(0.99, 0.01))
storm_time <- sample(c(0,1), prob = c(0.99, 0.01))
while(datecnt <= 24*timefromSQL){
points <- NULL
point <- NULL
dataframeForStats <- NULL
i = 1
print(datecnt)
while (i <= dim(locationSen)[1]){
#print(i)
point <- sortPM(datefromSQL, cityGrid[trunc(locationSen[i,1]/20) + city_grid_radius, trunc(locationSen[i,2]/20) + city_grid_radius], storm_time)
points <- rbind(points, point)
i <- i + 1
}
#data_tester <- cbind(locationSen, points)
#Run MlClassifier Once then will be able to predict for any pm values
try <- data_label(points, example[montht])
z <- priority_destinations(locationSen, try, 0)
dataframeForStats <- data.frame(try, "x"=locationSen[,1], "y"=locationSen[,2])
bigData <- rbind(bigData, dataframeForStats)
updates <- nearest_sensor_finder(z, locationSen, 0, try)
locationSen <- updates
datefromSQL <- datefromSQL + 60*60
storm_time <- sample(c(0,1), prob = c(0.99, 0.01))
datecnt <- datecnt + 1
}
best <- locationSen
plot(best[,1],best[,2], xlim = c(-geoRadius,geoRadius), ylim = c(-geoRadius,geoRadius), pch = 20, xlab = "X", ylab = "Y")
points(best[,1][which(best[,3]==1)],best[,2][which(best[,3]==1)], col = "green",pch = 20)
legend("topleft", legend = c("Fixed", "Mobile"), col = c("Black","Green"), pch = c(20,20), cex = 0.5)
title("Default Sensor Locations")
circle(0,0,geoRadius)
datecnt <- 1
#Generated Pm Values
locationSen <- MappedNetwork$best
locationSen <- cbind(locationSen, "moving"= rep(0, length(locationSen[,1])))
timefromSQL <- 1
datefromSQL <- as.POSIXlt("2019-09-06 20:51:50 CET")
montht <- format(datefromSQL,"%B")
points <- NULL
point <- NULL
dataframeForStates <- NULL
bigData <- NULL
datecnt <- 1
OGmap <- locationSen
storm_time <- sample(c(0,1), prob = c(0.99, 0.01))
while(datecnt <= 24*timefromSQL){
points <- NULL
point <- NULL
dataframeForStats <- NULL
i = 1
print(datecnt)
while (i <= dim(locationSen)[1]){
#print(i)
point <- sortPM(datefromSQL, cityGrid[trunc(locationSen[i,1]/20) + city_grid_radius, trunc(locationSen[i,2]/20) + city_grid_radius], storm_time)
points <- rbind(points, point)
i <- i + 1
}
#data_tester <- cbind(locationSen, points)
#Run MlClassifier Once then will be able to predict for any pm values
try <- data_label(points, example[montht])
z <- priority_destinations(locationSen, try, 0)
dataframeForStats <- data.frame(try, "x"=locationSen[,1], "y"=locationSen[,2])
bigData <- rbind(bigData, dataframeForStats)
updates <- nearest_sensor_finder(z, locationSen, 0, try)
locationSen <- updates
datefromSQL <- datefromSQL + 60*60
storm_time <- sample(c(0,1), prob = c(0.99, 0.01))
datecnt <- datecnt + 1
}
best <- locationSen
plot(best[,1],best[,2], xlim = c(-geoRadius,geoRadius), ylim = c(-geoRadius,geoRadius), pch = 20, xlab = "X", ylab = "Y")
points(best[,1][which(best[,3]==1)],best[,2][which(best[,3]==1)], col = "green",pch = 20)
legend("topleft", legend = c("Fixed", "Mobile"), col = c("Black","Green"), pch = c(20,20), cex = 0.5)
title("Default Sensor Locations")
circle(0,0,geoRadius)
source('~/IE 332/IE332group27/g27/Super Script.R')
source('~/IE 332/IE332group27/g27/Super Script.R')
#Generated Pm Values
locationSen <- MappedNetwork$best
locationSen <- cbind(locationSen, "moving"= rep(0, length(locationSen[,1])))
timefromSQL <- 1
datefromSQL <- as.POSIXlt("2019-09-06 20:51:50 CET")
montht <- format(datefromSQL,"%B")
points <- NULL
point <- NULL
dataframeForStates <- NULL
bigData <- NULL
datecnt <- 1
OGmap <- locationSen
storm_time <- sample(c(0,1), prob = c(0.99, 0.01))
while(datecnt <= 24*timefromSQL){
points <- NULL
point <- NULL
dataframeForStats <- NULL
i = 1
print(datecnt)
while (i <= dim(locationSen)[1]){
#print(i)
point <- sortPM(datefromSQL, cityGrid[trunc(locationSen[i,1]/20) + city_grid_radius, trunc(locationSen[i,2]/20) + city_grid_radius], storm_time)
points <- rbind(points, point)
i <- i + 1
}
#data_tester <- cbind(locationSen, points)
#Run MlClassifier Once then will be able to predict for any pm values
try <- data_label(points, example[montht])
z <- priority_destinations(locationSen, try, 0)
dataframeForStats <- data.frame(try, "x"=locationSen[,1], "y"=locationSen[,2])
bigData <- rbind(bigData, dataframeForStats)
updates <- nearest_sensor_finder(z, locationSen, 0, try)
locationSen <- updates
datefromSQL <- datefromSQL + 60*60
storm_time <- sample(c(0,1), prob = c(0.99, 0.01))
datecnt <- datecnt + 1
}
#Generated Pm Values
locationSen <- MappedNetwork$best
locationSen <- cbind(locationSen, "moving"= rep(0, length(locationSen[,1])))
timefromSQL <- 1
datefromSQL <- as.POSIXlt("2019-09-06 20:51:50 CET")
montht <- format(datefromSQL,"%B")
points <- NULL
point <- NULL
dataframeForStates <- NULL
bigData <- NULL
datecnt <- 1
OGmap <- locationSen
storm_time <- sample(c(0,1), prob = c(0.99, 0.01))
i = 1
best <- locationSen
plot(best[,1],best[,2], xlim = c(-geoRadius,geoRadius), ylim = c(-geoRadius,geoRadius), pch = 20, xlab = "X", ylab = "Y")
points(best[,1][which(best[,3]==1)],best[,2][which(best[,3]==1)], col = "green",pch = 20)
legend("topleft", legend = c("Fixed", "Mobile"), col = c("Black","Green"), pch = c(20,20), cex = 0.5)
title("Default Sensor Locations")
circle(0,0,geoRadius)
while(datecnt <= 24*timefromSQL){
points <- NULL
point <- NULL
dataframeForStats <- NULL
i = 1
print(datecnt)
while (i <= dim(locationSen)[1]){
#print(i)
point <- sortPM(datefromSQL, cityGrid[trunc(locationSen[i,1]/20) + city_grid_radius, trunc(locationSen[i,2]/20) + city_grid_radius], storm_time)
points <- rbind(points, point)
i <- i + 1
}
#data_tester <- cbind(locationSen, points)
#Run MlClassifier Once then will be able to predict for any pm values
try <- data_label(points, example[montht])
z <- priority_destinations(locationSen, try, 0)
dataframeForStats <- data.frame(try, "x"=locationSen[,1], "y"=locationSen[,2])
bigData <- rbind(bigData, dataframeForStats)
updates <- nearest_sensor_finder(z, locationSen, 0, try)
locationSen <- updates
datefromSQL <- datefromSQL + 60*60
storm_time <- sample(c(0,1), prob = c(0.99, 0.01))
datecnt <- datecnt + 1
}
point <- NULL
dataframeForStats <- NULL
i = 1
print(datecnt)
while (i <= dim(locationSen)[1]){
#print(i)
point <- sortPM(datefromSQL, cityGrid[trunc(locationSen[i,1]/20) + city_grid_radius, trunc(locationSen[i,2]/20) + city_grid_radius], storm_time)
points <- rbind(points, point)
i <- i + 1
}
warnings()
points
storm_time <- sample(c(0,1), 1, prob = c(0.99, 0.01))
while(datecnt <= 24*timefromSQL){
points <- NULL
point <- NULL
dataframeForStats <- NULL
i = 1
print(datecnt)
while (i <= dim(locationSen)[1]){
#print(i)
point <- sortPM(datefromSQL, cityGrid[trunc(locationSen[i,1]/20) + city_grid_radius, trunc(locationSen[i,2]/20) + city_grid_radius], storm_time)
points <- rbind(points, point)
i <- i + 1
}
#data_tester <- cbind(locationSen, points)
#Run MlClassifier Once then will be able to predict for any pm values
try <- data_label(points, example[montht])
z <- priority_destinations(locationSen, try, 0)
dataframeForStats <- data.frame(try, "x"=locationSen[,1], "y"=locationSen[,2])
bigData <- rbind(bigData, dataframeForStats)
updates <- nearest_sensor_finder(z, locationSen, 0, try)
locationSen <- updates
datefromSQL <- datefromSQL + 60*60
storm_time <- sample(c(0,1), prob = c(0.99, 0.01))
datecnt <- datecnt + 1
}
best <- locationSen
plot(best[,1],best[,2], xlim = c(-geoRadius,geoRadius), ylim = c(-geoRadius,geoRadius), pch = 20, xlab = "X", ylab = "Y")
points(best[,1][which(best[,3]==1)],best[,2][which(best[,3]==1)], col = "green",pch = 20)
legend("topleft", legend = c("Fixed", "Mobile"), col = c("Black","Green"), pch = c(20,20), cex = 0.5)
title("Default Sensor Locations")
circle(0,0,geoRadius)
source('~/IE 332/IE332group27/g27/Super Script.R')
warnings()
?dbfetch
?dbFetch
source('~/IE 332/IE332group27/g27/Super Script.R')
#initialization
budget <- 300000
cityGrid <- buildCity(3)
geoRadius <- 15000
city_grid_radius <- geoRadius / 20
MappedNetwork<- SA(budget, cityGrid, geoRadius = 15000, just_values = F)
example <- MlClassifier()
