}
if (action == "down" & allowed(curstate,n,actioncor,action)==TRUE)
{
curstate[1] <- actioncor["down1"]+ curstate[1]
curstate[2] <- actioncor["down2"]+ curstate[2]
}
if (action == "left" & allowed(curstate,n,actioncor,action)==TRUE)
{
curstate[1] <- actioncor["left1"]+ curstate[1]
curstate[2] <- actioncor["left2"]+ curstate[2]
}
if (action == "right" & allowed(curstate,n,actioncor,action)==TRUE)
{
curstate[1] <- actioncor["right1"]+ curstate[1]
curstate[2] <- actioncor["right2"]+ curstate[2]
}
if (action == "NE" & allowed(curstate,n,actioncor,action)==TRUE)
{
curstate[1] <- actioncor["NE1"]+ curstate[1]
curstate[2] <- actioncor["NE2"]+ curstate[2]
}
if (action == "NW" & allowed(curstate,n,actioncor,action)==TRUE)
{
curstate[1] <- actioncor["NW1"]+ curstate[1]
curstate[2] <- actioncor["NW2"]+ curstate[2]
}
if (action == "SW" & allowed(curstate,n,actioncor,action)==TRUE)
{
curstate[1] <- actioncor["SW1"]+ curstate[1]
curstate[2] <- actioncor["SW2"]+ curstate[2]
}
if (action == "SE" & allowed(curstate,n,actioncor,action)==TRUE)
{
curstate[1] <- actioncor["SE1"]+ curstate[1]
curstate[2] <- actioncor["SE2"]+ curstate[2]
}
if(curstate[1] == n & curstate[2] == n)
{
reward <- 100
}
else{
reward <- -1
}
print(reward)
out <- list(NextState = statemat[curstate[1],curstate[2]], Reward = reward)
return(out)
}
statemat <- matrix(paste0("s",rep(1:n^2)),n,n)
statemat
actioncor <- c("up"=c(0,-1), "down"=c(0,1), "left"=c(-1,0), "right"=c(1,0),"NW"=c(-1,-1), "NE"=c(1,-1),"SW"=c(-1,1),"SE"=c(1,1))
x<-which(statemat == state, arr.ind=T)
sampleExperience(N = 1000, env= enviornmentQ, states= states, actions = actions)
allowed <- function(cor,n,actioncor, action)
{
if(action == "up" & (cor[2] + actioncor["up2"]<1)){
return(FALSE)
}
if(action == "down" & (cor[2] + actioncor['down2']>n)){
return(FALSE)
}
if(action == "left" & (cor[1] + actioncor["left1"]<1)){
return(FALSE)
}
if(action == "right" & (cor[1] + actioncor["right1"]>n)){
return(FALSE)
}
if(action == "NW" & ((cor[1] + actioncor["NW1"]<1)|(cor[2] + actioncor["NW2"]<1))){
return(FALSE)
}
if(action == "SE" & ((cor[1] + actioncor["SE1"]>n)|(cor[2] + actioncor["SE2"]>n))){
return(FALSE)
}
if(action == "NE" & ((cor[1] + actioncor["NE1"]>n)|(cor[2] + actioncor["NE2"]<1))){
return(FALSE)
}
if(action == "SW" & ((cor[1] + actioncor["SW1"]<1)|(cor[2] + actioncor["SW2"]>n))){
return(FALSE)
}
else{
return(TRUE)
}
}
sampleExperience(N = 1000, env= enviornmentQ, states= states, actions = actions)
data <- env <- enviornmentQ(state, actions, actioncor, n)
control <- list(alpha = 0.1, gamma = 0.5, epsilon = 0.1)
model <- ReinforcementLearning(data, s = "state", a="Action", r="reward", s_new="NextState", control = control)
data <- env <- enviornmentQ(state, actions, actioncor, n)
enviornmentQ <- function (state, action)
{
print(state)
n <- 3
statemat <- matrix(paste0("s",rep(1:n^2)),n,n)
actioncor <- c("up"=c(0,-1), "down"=c(0,1), "left"=c(-1,0), "right"=c(1,0),"NW"=c(-1,-1), "NE"=c(1,-1),"SW"=c(-1,1),"SE"=c(1,1))
x<-which(statemat == state, arr.ind=T)
curstate <- c(x[1],x[2])
print(curstate)
next_state <- state
if (action == "up" & allowed(curstate,n,actioncor,action)==TRUE)
{
curstate[1] <- actioncor["up1"] + curstate[1]
curstate[2] <- actioncor["up2"]+ curstate[2]
}
if (action == "down" & allowed(curstate,n,actioncor,action)==TRUE)
{
curstate[1] <- actioncor["down1"]+ curstate[1]
curstate[2] <- actioncor["down2"]+ curstate[2]
}
if (action == "left" & allowed(curstate,n,actioncor,action)==TRUE)
{
curstate[1] <- actioncor["left1"]+ curstate[1]
curstate[2] <- actioncor["left2"]+ curstate[2]
}
if (action == "right" & allowed(curstate,n,actioncor,action)==TRUE)
{
curstate[1] <- actioncor["right1"]+ curstate[1]
curstate[2] <- actioncor["right2"]+ curstate[2]
}
if (action == "NE" & allowed(curstate,n,actioncor,action)==TRUE)
{
curstate[1] <- actioncor["NE1"]+ curstate[1]
curstate[2] <- actioncor["NE2"]+ curstate[2]
}
if (action == "NW" & allowed(curstate,n,actioncor,action)==TRUE)
{
curstate[1] <- actioncor["NW1"]+ curstate[1]
curstate[2] <- actioncor["NW2"]+ curstate[2]
}
if (action == "SW" & allowed(curstate,n,actioncor,action)==TRUE)
{
curstate[1] <- actioncor["SW1"]+ curstate[1]
curstate[2] <- actioncor["SW2"]+ curstate[2]
}
if (action == "SE" & allowed(curstate,n,actioncor,action)==TRUE)
{
curstate[1] <- actioncor["SE1"]+ curstate[1]
curstate[2] <- actioncor["SE2"]+ curstate[2]
}
if(curstate[1] == n & curstate[2] == n)
{
reward <- 100
}
else{
reward <- -1
}
print(reward)
out <- list(NextState = statemat[curstate[1],curstate[2]], Reward = reward)
return(out)
}
data <- sampleExperience(N = 1000, env = enviornmentQ, states = states, actions = actions)
data
model <- ReinforcementLearning(data, s = "state", a="Action", r="reward", s_new="NextState", control = control)
data
control <- list(alpha = 0.1, gamma = 0.5, epsilon = 0.1)
model <- ReinforcementLearning(data, s = "State", a="Action", r="Reward", s_new="NextState", control = control)
model
# Print summary statistics
summary(model)
data <- sampleExperience(N = 1000, env = enviornmentQ, states = states, actions = actions)
model <- ReinforcementLearning(data, s = "State", a="Action", r="Reward", s_new="NextState", control = control)
model
n<- 10
data <- sampleExperience(N = 1000, env = enviornmentQ, states = states, actions = actions)
model <- ReinforcementLearning(data, s = "State", a="Action", r="Reward", s_new="NextState", control = control)
model
enviornmentQ <- function (state, action)
{
n <- 10
statemat <- matrix(paste0("s",rep(1:n^2)),n,n)
actioncor <- c("up"=c(0,-1), "down"=c(0,1), "left"=c(-1,0), "right"=c(1,0),"NW"=c(-1,-1), "NE"=c(1,-1),"SW"=c(-1,1),"SE"=c(1,1))
x<-which(statemat == state, arr.ind=T)
curstate <- c(x[1],x[2])
next_state <- state
if (action == "up" & allowed(curstate,n,actioncor,action)==TRUE)
{
curstate[1] <- actioncor["up1"] + curstate[1]
curstate[2] <- actioncor["up2"]+ curstate[2]
}
if (action == "down" & allowed(curstate,n,actioncor,action)==TRUE)
{
curstate[1] <- actioncor["down1"]+ curstate[1]
curstate[2] <- actioncor["down2"]+ curstate[2]
}
if (action == "left" & allowed(curstate,n,actioncor,action)==TRUE)
{
curstate[1] <- actioncor["left1"]+ curstate[1]
curstate[2] <- actioncor["left2"]+ curstate[2]
}
if (action == "right" & allowed(curstate,n,actioncor,action)==TRUE)
{
curstate[1] <- actioncor["right1"]+ curstate[1]
curstate[2] <- actioncor["right2"]+ curstate[2]
}
if (action == "NE" & allowed(curstate,n,actioncor,action)==TRUE)
{
curstate[1] <- actioncor["NE1"]+ curstate[1]
curstate[2] <- actioncor["NE2"]+ curstate[2]
}
if (action == "NW" & allowed(curstate,n,actioncor,action)==TRUE)
{
curstate[1] <- actioncor["NW1"]+ curstate[1]
curstate[2] <- actioncor["NW2"]+ curstate[2]
}
if (action == "SW" & allowed(curstate,n,actioncor,action)==TRUE)
{
curstate[1] <- actioncor["SW1"]+ curstate[1]
curstate[2] <- actioncor["SW2"]+ curstate[2]
}
if (action == "SE" & allowed(curstate,n,actioncor,action)==TRUE)
{
curstate[1] <- actioncor["SE1"]+ curstate[1]
curstate[2] <- actioncor["SE2"]+ curstate[2]
}
if(curstate[1] == n & curstate[2] == n)
{
reward <- 100
}
else{
reward <- -1
}
print(reward)
out <- list(NextState = statemat[curstate[1],curstate[2]], Reward = reward)
return(out)
}
data <- sampleExperience(N = 1000, env = enviornmentQ, states = states, actions = actions)
model <- ReinforcementLearning(data, s = "State", a="Action", r="Reward", s_new="NextState", control = control)
model
source('~/IE 332/code/IE332 A3/A3Q2.R')
states <- paste0("s",rep(1:n^2))
statemat <- matrix(paste0("s",rep(1:n^2)),n,n)
data <- sampleExperience(N = 1000, env = enviornmentQ, states = states, actions = actions)
model <- ReinforcementLearning(data, s = "State", a="Action", r="Reward", s_new="NextState", control = control)
model
setwd("~/IE 332/IE332group27/g27")
require(readr) #input/output
require(dplyr) #data wrangling
require(lubridate) #date/time
require(knitr) #quite fond of the kable function for making tables.
require(ggplot2) #plotting
require(ggthemes) #plotting
require(gridExtra) #extra space for plots
require(leaflet) #mapping
require(leaflet.extras) #mapping
require(data.table) #data manipulation
require(RColorBrewer) #plotting
require(stringr) #more data wrangling
require(ggridges) #plotting density ridges
#x: randomized number from regression to be "collected" by sensor.
require(truncnorm)
library(berryFunctions)
install.packages("berryFunctions")
library(berryFunctions)
install.packages(c("berryFunctions", "lpSolve"))
install.packages(c("berryFunctions", "lpSolve"))
source('~/IE 332/IE332group27/g27/OptimizationProblem.R')
rm(list=ls())
source('~/IE 332/IE332group27/g27/OptimizationProblem.R')
source('~/IE 332/IE332group27/g27/randomCollect.R')
source('~/IE 332/IE332group27/g27/smoothing_reg_month_maker.R')
source('~/IE 332/IE332group27/g27/sortPMtest.R')
source('~/IE 332/IE332group27/g27/Sorting for Simulation Data.R')
source('~/IE 332/IE332group27/g27/Sorting for Simulation Data.R')
randomMap <- create_random(100)
randomMap <- create_random(100)
randomMap <- create_random(c(100,100))
randomMap
solution <- budget_constraint(100000)
require(lpSolve)
solution <- budget_constraint(100000)
solution
solution <- budget_constraint(1000000)
randomMap <- create_random(solution)
randomMap
library(berryFunctions)
plot(best[,1],best[,2], xlim = c(-geoRadius,geoRadius), ylim = c(-geoRadius,geoRadius), pch = 20, xlab = "X", ylab = "Y")
Map<- SA(10000000)
source('~/IE 332/IE332group27/g27/MLclassifier.R')
MlClassifier()
MlClassifier()
source('~/IE 332/IE332group27/g27/MLclassifier.R')
MlClassifier()
exaples <- data_label(c(10, 10, 10), nB)
january = as_tibble(fread("air-quality-data-from-extensive-network-of-sensors/january-2017.csv"))
february = as_tibble(fread("air-quality-data-from-extensive-network-of-sensors/february-2017.csv"))
march = as_tibble(fread("air-quality-data-from-extensive-network-of-sensors/march-2017.csv"))
april = as_tibble(fread("air-quality-data-from-extensive-network-of-sensors/april-2017.csv"))
may = as_tibble(fread("air-quality-data-from-extensive-network-of-sensors/may-2017.csv"))
june = as_tibble(fread("air-quality-data-from-extensive-network-of-sensors/june-2017.csv"))
july = as_tibble(fread("air-quality-data-from-extensive-network-of-sensors/july-2017.csv"))
august = as_tibble(fread("air-quality-data-from-extensive-network-of-sensors/august-2017.csv"))
september = as_tibble(fread("air-quality-data-from-extensive-network-of-sensors/september-2017.csv"))
october = as_tibble(fread("air-quality-data-from-extensive-network-of-sensors/october-2017.csv"))
november = as_tibble(fread("air-quality-data-from-extensive-network-of-sensors/november-2017.csv"))
december = as_tibble(fread("air-quality-data-from-extensive-network-of-sensors/december-2017.csv"))
Sys.setenv(TZ='Poland') #we're looking at data from Poland, to avoid erors we'll use this command. If this is not given a timezone error will appear.
january$`UTC time` = as_datetime(january$`UTC time`)
february$`UTC time` = as_datetime(february$`UTC time`)
march$`UTC time` = as_datetime(march$`UTC time`)
april$`UTC time` = as_datetime(april$`UTC time`)
may$`UTC time` = as_datetime(may$`UTC time`)
june$`UTC time` = as_datetime(june$`UTC time`)
july$`UTC time` = as_datetime(july$`UTC time`)
august$`UTC time` = as_datetime(august$`UTC time`)
september$`UTC time` = as_datetime(september$`UTC time`)
october$`UTC time` = as_datetime(october$`UTC time`)
november$`UTC time` = as_datetime(november$`UTC time`)
december$`UTC time` = as_datetime(december$`UTC time`)
jan.test = january %>% select(contains("pm"))
feb.test = february %>% select(contains("pm"))
mar.test = march %>% select(contains("pm"))
apr.test = april %>% select(contains("pm"))
may.test = may %>% select(contains("pm"))
jun.test = june %>% select(contains("pm"))
jul.test = july %>% select(contains("pm"))
aug.test = august %>% select(contains("pm"))
sep.test = september %>% select(contains("pm"))
oct.test = october %>% select(contains("pm"))
nov.test = november %>% select(contains("pm"))
dec.test = december %>% select(contains("pm"))
# create a function to replace NA values with the median
# medrep = function(i){
#   i[is.na(i)] = median(i, na.rm=TRUE)
#   as.numeric(i)
# }
# jan.med = data.frame(apply(jan.test,2,medrep))
# feb.med = data.frame(apply(feb.test,2,medrep))
# mar.med = data.frame(apply(mar.test,2,medrep))
# apr.med = data.frame(apply(apr.test,2,medrep))
# may.med = data.frame(apply(may.test,2,medrep))
# jun.med = data.frame(apply(jun.test,2,medrep))
# jul.med = data.frame(apply(jul.test,2,medrep))
# aug.med = data.frame(apply(aug.test,2,medrep))
# sep.med = data.frame(apply(sep.test,2,medrep))
# oct.med = data.frame(apply(oct.test,2,medrep))
# nov.med = data.frame(apply(nov.test,2,medrep))
# dec.med = data.frame(apply(dec.test,2,medrep))
yr.noname = data.frame(   # to store 3 cols of all sensor data from all months
pm010 = jan.test$`3_pm1`,
pm025 = jan.test$`3_pm25`,
pm100 = jan.test$`3_pm10`
)
next3rep = function(df.noname, df.test, col = 1){
while(col <= length(df.test)-2) {
df.next3 = df.test[col:(col+2)]
names(df.next3) = c("pm010", "pm025", "pm100")
df.noname = rbind(df.noname, df.next3)
col = col+3
}
return(df.noname)
}
yr.noname = next3rep(yr.noname, jan.test, col = 4)  # fill rest of jan
yr.noname = next3rep(yr.noname, feb.test)  # fill with feb
yr.noname = next3rep(yr.noname, mar.test)  # fill with mar
yr.noname = next3rep(yr.noname, apr.test)  # fill with apr
yr.noname = next3rep(yr.noname, may.test)  # fill with may
yr.noname = next3rep(yr.noname, jun.test)  # fill with jun
yr.noname = next3rep(yr.noname, jul.test)  # fill with jul
yr.noname = next3rep(yr.noname, aug.test)  # fill with aug
yr.noname = next3rep(yr.noname, sep.test)  # fill with sep
yr.noname = next3rep(yr.noname, oct.test)  # fill with oct
yr.noname = next3rep(yr.noname, nov.test)  # fill with nov
yr.noname = next3rep(yr.noname, dec.test)  # fill with dec
yr.noname[yr.noname < 0] = NA   # mark negative values NA
yr.noname = na.omit(yr.noname)  # eventually omit NA
# we need to remove outliers using interquartile range
outliers1 = boxplot.stats(yr.noname[ ,1],coef = 3)$out
outliers2 = boxplot.stats(yr.noname[ ,2],coef = 3)$out
outliers3 = boxplot.stats(yr.noname[ ,3],coef = 3)$out
yr.nout = yr.noname[-which(yr.noname[ ,1] %in% outliers1), ]
yr.nout = yr.noname[-which(yr.noname[ ,2] %in% outliers2), ]
yr.nout = yr.noname[-which(yr.noname[ ,3] %in% outliers3), ]
rownames(yr.nout) = NULL
# can delete, comparing frequencies removing outliers
par(mfrow=c(2,1))
plot(count(yr.noname$pm010))
plot(count(yr.nout$pm010))
plot(count(yr.noname$pm025))
plot(count(yr.nout$pm025))
plot(count(yr.noname$pm100))
plot(count(yr.nout$pm100))
hist(yr.noname$pm100)
hist(yr.nout$pm100)
# statistics
# yr.avg_pm010 = mean(yr.noname$pm010)
# yr.avg_pm025 = mean(yr.noname$pm025)
# yr.avg_pm100 = mean(yr.noname$pm100)
yr.avg_pm010 = mean(yr.nout$pm010)
yr.avg_pm025 = mean(yr.nout$pm025)
yr.avg_pm100 = mean(yr.nout$pm100)
# can delete, comparing frequencies
count(as.factor(ifelse(yr.noname$pm010 >= yr.avg_pm010, 1, 0)))
count(as.factor(ifelse(yr.noname$pm025 >= yr.avg_pm025, 1, 0)))
count(as.factor(ifelse(yr.noname$pm100 >= yr.avg_pm100, 1, 0)))
count(as.factor(ifelse(yr.nout$pm010 >= yr.avg_pm010, 1, 0)))
count(as.factor(ifelse(yr.nout$pm025 >= yr.avg_pm025, 1, 0)))
count(as.factor(ifelse(yr.nout$pm100 >= yr.avg_pm100, 1, 0)))
# preparing factors for training based on means after outliers removed, per pm level
yr.nout$pm010.label = as.factor(ifelse(yr.nout$pm010 >= yr.avg_pm010, 1, 0))
yr.nout$pm025.label = as.factor(ifelse(yr.nout$pm025 >= yr.avg_pm025, 1, 0))
yr.nout$pm100.label = as.factor(ifelse(yr.nout$pm100 >= yr.avg_pm100, 1, 0))
yr.nout$rating = as.numeric(as.character(yr.nout[,4])) + as.numeric(as.character(yr.nout[,5])) + as.numeric(as.character(yr.nout[,6]))  # row-sum of pm factors
yr.nout$rating = factor(yr.nout$rating) # back to factor with Levels: {0, 1, 2, 3} in order of 'best' to 'worst'
#set.seed(1030)
trainIndex = createDataPartition(yr.nout$rating, p=0.75)$Resample1
train = yr.nout[trainIndex, ]
test = yr.nout[-trainIndex, ]
#x = train[, c("pm010", "pm025", "pm100")]
#yr.nB = naiveBayes(x, train$rating)
yr.nB = naiveBayes(rating ~ pm010 + pm025 + pm100, data=train) # uses *.label cols
yr.trainPred = predict(yr.nB, newdata = train)
yr.trainTable = table(train$rating, yr.trainPred)
yr.testPred = predict(yr.nB, newdata = test)
yr.testTable = table(test$rating, yr.testPred)
confusionMatrix(yr.testPred, test$rating)$overall['Accuracy']
test
yr.testPred = predict(yr.nB, newdata = test)
yr.testPred
yr.testPred = predict(yr.nB, newdata = test[1:3])
yr.testPred
exaples <- data_label(c(10, 10, 10), nB)
nB <- MlClassifier()
exaples <- data_label(c(10, 10, 10), nB)
exaples
exaples <- data_label(c("pm010"=10, "pm025"=10, "pm100"=10), nB)
examples <- data_label(c("pm010"=10, "pm025"=10, "pm100"=10), nB)
source('~/IE 332/IE332group27/g27/MLclassifier.R')
nB <- MlClassifier(data.frame(c("pm010"=10, "pm025"=10, "pm100"=10)))
nB
examples <- data_label("pm010"=10, "pm025"=10, "pm100"=10, nB)
examples <- data_label(data.frame("pm010"=10, "pm025"=10, "pm100"=10), nB)
data.frame(("pm010"=10, "pm025"=10, "pm100"=10))
data.frame("pm010"=10, "pm025"=10, "pm100"=10)
yr.trainPred = predict(yr.nB, newdata = train)
yr.trainPred
test[1:3]
class(test[1:3])
testdata = predict(yr.nB, newdata = pm_data)
pm_data <- data.frame("pm010"=10, "pm025"=10, "pm100"=10)
testdata = predict(yr.nB, newdata = pm_data)
testdata
pm_data
testdata
combined= cbind(pm_data, "label" = testdata)
combined
test <- data.frame("pm010"=100, "pm025"=100, "pm100"=100)
example <- MlClassifier(test)
exapmple
example
Map<- SA(10000000)
geoRadius <- 15000/20
cityGrid <- matrix(rep(-1,(2*geoRadius)^2), 2*geoRadius, 2*geoRadius)
for(i in -geoRadius:geoRadius){
for(j in -geoRadius:geoRadius){
dist <- sqrt(i^2+j^2)
if(dist<=geoRadius){
cityGrid[i+geoRadius,j+geoRadius] <- 0
}
}
}
#Top left residential
for(x in 1:500){
for(y in 1001:1500){
if(cityGrid[x,y] != -1){
cityGrid[x,y]<-1
}
}
}
#Top right residential
for(x in 1001:1500){
for(y in 1001:1500){
if(cityGrid[x,y] != -1){
cityGrid[x,y]<-1
}
}
}
#Bottom left residential
for(x in 1:500){
for(y in 1:500){
if(cityGrid[x,y] != -1){
cityGrid[x,y]<-1
}
}
}
#Bottom right residential
for(x in 1001:1500){
for(y in 1:500){
if(cityGrid[x,y] != -1){
cityGrid[x,y]<-1
}
}
}
#Center industrial
for(x in 501:1000){
for(y in 501:1000){
if(cityGrid[x,y] != -1){
cityGrid[x,y]<-2
}
}
}
image(cityGrid, col = c("black","green","blue", "yellow"))
cityGrid
Map<- SA(10000000, cityGrid)
map
Map
MappedNetwork<- SA(10000000, cityGrid)
MappedNetwork<- SA(10000000)
MappedNetwork<- SA(1000000)
MappedNetwork
source('~/IE 332/IE332group27/g27/code.R')
install.packages("RANN")
source('~/IE 332/IE332group27/g27/code.R')
source('~/IE 332/IE332group27/g27/smoothing_reg_month_maker.R')
source('~/IE 332/IE332group27/g27/sortPMtest.R')
