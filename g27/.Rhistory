points <- rbind(points, point)
i <- i + 1
}
#data_tester <- cbind(locationSen, points)
#Run MlClassifier Once then will be able to predict for any pm values
try <- data_label(points, example[montht])
z <- priority_destinations(locationSen, try, airPref)
dataframeForStats <- data.frame(try, "x"=locationSen[,1], "y"=locationSen[,2])
bigData <- rbind(bigData, dataframeForStats)
updates <- nearest_sensor_finder(z, locationSen, airPref, try)
locationSen <- updates
datefromSQL <- datefromSQL + 60*60
storm_time <- sample(c(0,1), 1, prob = c(0.99, 0.01))
datecnt <- datecnt + 1
}
updates <- nearest_sensor_finder(z, locationSen, airPref, try)
updates
z
locationSen
try
destination <- z
sensors <- locationSen
quality_desired <- airPref
pm_class <- pm_dats
pm_class <- pm_data
pm_class <- try
#destination: final destination for sensor to move to
#sensors: data frame of all sensors in the network
#quality_desired: the type of air quality the client desires to know more about ("good" or "bad")(client-defined)
#pm_data: the classification of the particulate matter collected by each sensor
for(k in 1:length(destination[,1])){
mobile_sensors <- sensors[which(sensors[,3]==1),]
num_mobiles <- length(mobile_sensors[,1])
dist_vec <- vector(length = num_mobiles)
for(i in 1:num_mobiles){
dist_vec[i] <- sqrt((destination[k,1] - mobile_sensors[i,1]) ^ 2 + (destination[k,2] - mobile_sensors[i,2]) ^ 2)
}
dist_vec <- unlist(dist_vec)
dist_vec[which(dist_vec == 0)] <- 15001
loop_iterate <- 1
nth_term <- 1
while(loop_iterate){
loop_iterate <- 1
nth_term <- nth_term + 1
if(nth_term > length(dist_vec)){
break
}
near_mobile_index <- which(dist_vec == dist_vec[order(dist_vec)][nth_term])
near_mobile <- mobile_sensors[near_mobile_index,]
near_index <- which(sensors[,1] == near_mobile[1] & sensors[,2] == near_mobile[2])
if(near_mobile[4] == 1){
loop_iterate <- 2
k <- k + 1
}
if(pm_class[near_index, 4] == quality_desired){
loop_iterate <- 2
k <- k + 1
}
if(loop_iterate == 1){
movement <- move_sensor(dist_vec[near_mobile_index], destination[k,], sensors[near_index,])
movement <- unlist(movement)
if(movement[3]){
sensors[near_index,4] <- 1
}
sensors[near_index,1] <- movement[1] + sensors[near_index,1]
sensors[near_index,2] <- movement[2] + sensors[near_index, 2]
if(!movement[3]){
sensors[near_index,4] == 0
}
}
loop_iterate <- loop_iterate - 1
}
}
i
j
k
dist_vec[i] <- sqrt((destination[k,1] - mobile_sensors[i,1]) ^ 2 + (destination[k,2] - mobile_sensors[i,2]) ^ 2)
dist_vec[38]
dist_vec
destination[k, 1]
destination
destination[k,2]
mobile_sensors[i,2]
1:length(destination[,1]
)
destination[,1]
length(destination[,1])
source('~/IE 332/IE332group27/g27/Super Script.R')
#Generated Pm Values
locationSen <- MappedNetwork$best
locationSen <- cbind(locationSen, "moving"= rep(0, length(locationSen[,1])))
timefromSQL <- 1
datefromSQL <- as.POSIXlt("2019-09-06 20:51:50 CET")
montht <- format(datefromSQL,"%B")
points <- NULL
point <- NULL
dataframeForStats <- NULL
bigData <- NULL
datecnt <- 1
OGmap <- locationSen
airPref <- 0
storm_time <- sample(c(0,1), 1, prob = c(0.99, 0.01))
while(datecnt <= 24*timefromSQL){
points <- NULL
point <- NULL
dataframeForStats <- NULL
updates <- NULL
i = 1
print(datecnt)
while (i <= dim(locationSen)[1]){
print("i")
print(i)
point <- sortPM(datefromSQL, cityGrid[trunc(locationSen[i,1]/20) + city_grid_radius, trunc(locationSen[i,2]/20) + city_grid_radius], storm_time)
points <- rbind(points, point)
i <- i + 1
}
#data_tester <- cbind(locationSen, points)
#Run MlClassifier Once then will be able to predict for any pm values
try <- data_label(points, example[montht])
z <- priority_destinations(locationSen, try, airPref)
dataframeForStats <- data.frame(try, "x"=locationSen[,1], "y"=locationSen[,2])
bigData <- rbind(bigData, dataframeForStats)
updates <- nearest_sensor_finder(z, locationSen, airPref, try)
locationSen <- updates
datefromSQL <- datefromSQL + 60*60
storm_time <- sample(c(0,1), 1, prob = c(0.99, 0.01))
datecnt <- datecnt + 1
}
i
cityGrid[trunc(locationSen[i,1]/20) + city_grid_radius, trunc(locationSen[i,2]/20) + city_grid_radius]
(locationSen[i,1]/20) + city_grid_radius
trunc(locationSen[i,2]/20) + city_grid_radius
i
locationSen
source('~/IE 332/IE332group27/g27/Super Script.R')
source('~/IE 332/IE332group27/g27/Super Script.R')
points <- NULL
point <- NULL
dataframeForStats <- NULL
bigData <- NULL
datecnt <- 1
OGmap <- locationSen
airPref <- 0
storm_time <- sample(c(0,1), 1, prob = c(0.99, 0.01))
while(datecnt <= 24*timefromSQL){
points <- NULL
point <- NULL
dataframeForStats <- NULL
updates <- NULL
i = 1
print(datecnt)
while (i <= dim(locationSen)[1]){
print("i")
print(i)
point <- sortPM(datefromSQL, cityGrid[trunc(locationSen[i,1]/20) + city_grid_radius, trunc(locationSen[i,2]/20) + city_grid_radius], storm_time)
points <- rbind(points, point)
i <- i + 1
}
#data_tester <- cbind(locationSen, points)
#Run MlClassifier Once then will be able to predict for any pm values
try <- data_label(points, example[montht])
z <- priority_destinations(locationSen, try, airPref)
dataframeForStats <- data.frame(try, "x"=locationSen[,1], "y"=locationSen[,2])
bigData <- rbind(bigData, dataframeForStats)
updates <- nearest_sensor_finder(z, locationSen, airPref, try)
locationSen <- updates
datefromSQL <- datefromSQL + 60*60
storm_time <- sample(c(0,1), 1, prob = c(0.99, 0.01))
datecnt <- datecnt + 1
}
#Generated Pm Values
locationSen <- MappedNetwork$best
while(datecnt <= 24*timefromSQL){
points <- NULL
point <- NULL
dataframeForStats <- NULL
updates <- NULL
i = 1
print(datecnt)
while (i <= dim(locationSen)[1]){
print("i")
print(i)
point <- sortPM(datefromSQL, cityGrid[trunc(locationSen[i,1]/20) + city_grid_radius, trunc(locationSen[i,2]/20) + city_grid_radius], storm_time)
points <- rbind(points, point)
i <- i + 1
}
#data_tester <- cbind(locationSen, points)
#Run MlClassifier Once then will be able to predict for any pm values
try <- data_label(points, example[montht])
z <- priority_destinations(locationSen, try, airPref)
dataframeForStats <- data.frame(try, "x"=locationSen[,1], "y"=locationSen[,2])
bigData <- rbind(bigData, dataframeForStats)
updates <- nearest_sensor_finder(z, locationSen, airPref, try)
locationSen <- updates
datefromSQL <- datefromSQL + 60*60
storm_time <- sample(c(0,1), 1, prob = c(0.99, 0.01))
datecnt <- datecnt + 1
}
locationSen
#Generated Pm Values
locationSen <- MappedNetwork$best
locationSen <- cbind(locationSen, "moving"= rep(0, length(locationSen[,1])))
#Generated Pm Values
locationSen <- MappedNetwork$best
locationSen <- cbind(locationSen, "moving"= rep(0, length(locationSen[,1])))
timefromSQL <- 1
datefromSQL <- as.POSIXlt("2019-09-06 20:51:50 CET")
montht <- format(datefromSQL,"%B")
points <- NULL
point <- NULL
dataframeForStats <- NULL
bigData <- NULL
datecnt <- 1
OGmap <- locationSen
airPref <- 0
storm_time <- sample(c(0,1), 1, prob = c(0.99, 0.01))
while(datecnt <= 24*timefromSQL){
points <- NULL
point <- NULL
dataframeForStats <- NULL
updates <- NULL
i = 1
print(datecnt)
while (i <= dim(locationSen)[1]){
print("i")
print(i)
point <- sortPM(datefromSQL, cityGrid[trunc(locationSen[i,1]/20) + city_grid_radius, trunc(locationSen[i,2]/20) + city_grid_radius], storm_time)
points <- rbind(points, point)
i <- i + 1
}
#data_tester <- cbind(locationSen, points)
#Run MlClassifier Once then will be able to predict for any pm values
try <- data_label(points, example[montht])
z <- priority_destinations(locationSen, try, airPref)
dataframeForStats <- data.frame(try, "x"=locationSen[,1], "y"=locationSen[,2])
bigData <- rbind(bigData, dataframeForStats)
updates <- nearest_sensor_finder(z, locationSen, airPref, try)
locationSen <- updates
datefromSQL <- datefromSQL + 60*60
storm_time <- sample(c(0,1), 1, prob = c(0.99, 0.01))
datecnt <- datecnt + 1
}
warning()
best <- locationSen
plot(best[,1],best[,2], xlim = c(-geoRadius,geoRadius), ylim = c(-geoRadius,geoRadius), pch = 20, xlab = "X", ylab = "Y")
points(best[,1][which(best[,3]==1)],best[,2][which(best[,3]==1)], col = "green",pch = 20)
legend("topleft", legend = c("Fixed", "Mobile"), col = c("Black","Green"), pch = c(20,20), cex = 0.5)
title("Default Sensor Locations")
circle(0,0,geoRadius)
bigData <- rbind(bigData, dataframeForStats)
bigData
rm(list = ls())
source('~/IE 332/IE332group27/g27/Super Script.R')
#initialization
budget <- 300000
cityType <- 1
cityGrid <- buildCity(cityType)
geoRadius <- 15000
city_grid_radius <- geoRadius / 20
MappedNetwork<- SA(budget, cityGrid, geoRadius = 15000, just_values = F)
example <- MlClassifier()
#Generated Pm Values
locationSen <- MappedNetwork$best
locationSen <- cbind(locationSen, "moving"= rep(0, length(locationSen[,1])))
timefromSQL <- 1
datefromSQL <- as.POSIXlt("2019-09-06 20:51:50 CET")
montht <- format(datefromSQL,"%B")
points <- NULL
point <- NULL
dataframeForStats <- NULL
bigData <- NULL
datecnt <- 1
OGmap <- locationSen
airPref <- 0
storm_time <- sample(c(0,1), 1, prob = c(0.99, 0.01))
while(datecnt <= 24*timefromSQL){
points <- NULL
point <- NULL
dataframeForStats <- NULL
updates <- NULL
i = 1
print(datecnt)
while (i <= dim(locationSen)[1]){
print("i")
print(i)
point <- sortPM(datefromSQL, cityGrid[trunc(locationSen[i,1]/20) + city_grid_radius, trunc(locationSen[i,2]/20) + city_grid_radius], storm_time)
points <- rbind(points, point)
i <- i + 1
}
#data_tester <- cbind(locationSen, points)
#Run MlClassifier Once then will be able to predict for any pm values
try <- data_label(points, example[montht])
z <- priority_destinations(locationSen, try, airPref)
dataframeForStats <- data.frame(try, "x"=locationSen[,1], "y"=locationSen[,2])
bigData <- rbind(bigData, dataframeForStats)
updates <- nearest_sensor_finder(z, locationSen, airPref, try)
locationSen <- updates
datefromSQL <- datefromSQL + 60*60
storm_time <- sample(c(0,1), 1, prob = c(0.99, 0.01))
datecnt <- datecnt + 1
}
source('~/IE 332/IE332group27/g27/Super Script.R')
bigData
#Generated Pm Values
locationSen <- MappedNetwork$best
locationSen <- cbind(locationSen, "moving"= rep(0, length(locationSen[,1])))
timefromSQL <- 1
datefromSQL <- as.POSIXlt("2019-09-06 20:51:50 CET")
montht <- format(datefromSQL,"%B")
points <- NULL
point <- NULL
dataframeForStats <- NULL
bigData <- NULL
datecnt <- 1
OGmap <- locationSen
airPref <- 0
storm_time <- sample(c(0,1), 1, prob = c(0.99, 0.01))
while(datecnt <= 24*timefromSQL){
points <- NULL
point <- NULL
dataframeForStats <- NULL
updates <- NULL
i = 1
print(datecnt)
while (i <= dim(locationSen)[1]){
print("i")
print(i)
point <- sortPM(datefromSQL, cityGrid[trunc(locationSen[i,1]/20) + city_grid_radius, trunc(locationSen[i,2]/20) + city_grid_radius], storm_time)
points <- rbind(points, point)
i <- i + 1
}
#data_tester <- cbind(locationSen, points)
#Run MlClassifier Once then will be able to predict for any pm values
try <- data_label(points, example[montht])
z <- priority_destinations(locationSen, try, airPref)
dataframeForStats <- data.frame(try, "x"=locationSen[,1], "y"=locationSen[,2])
bigData <- rbind(bigData, dataframeForStats)
updates <- nearest_sensor_finder(z, locationSen, airPref, try)
locationSen <- updates
datefromSQL <- datefromSQL + 60*60
storm_time <- sample(c(0,1), 1, prob = c(0.99, 0.01))
datecnt <- datecnt + 1
}
points
try
z
dataframeForStats
bigData
updates
updates
source('~/IE 332/IE332group27/g27/Super Script.R')
updates <- nearest_sensor_finder(z, locationSen, airPref, try)
#initialization
budget <- 300000
cityType <- 1
cityGrid <- buildCity(cityType)
geoRadius <- 15000
city_grid_radius <- geoRadius / 20
MappedNetwork<- SA(budget, cityGrid, geoRadius = 15000, just_values = F)
example <- MlClassifier()
#Generated Pm Values
locationSen <- MappedNetwork$best
locationSen <- cbind(locationSen, "moving"= rep(0, length(locationSen[,1])))
timefromSQL <- 1
datefromSQL <- as.POSIXlt("2019-09-06 20:51:50 CET")
datefromSQL <- as.POSIXlt(datefromSQL)
montht <- format(datefromSQL,"%B")
points <- NULL
point <- NULL
dataframeForStats <- NULL
bigData <- NULL
datecnt <- 1
OGmap <- locationSen
airPref <- 0
storm_time <- sample(c(0,1), 1, prob = c(0.99, 0.01))
while(datecnt <= 24*timefromSQL){
points <- NULL
point <- NULL
dataframeForStats <- NULL
i = 1
print(datecnt)
while (i <= dim(locationSen)[1]){
print(i)
point <- sortPM(datefromSQL, cityGrid[trunc(locationSen[i,1]/20) + city_grid_radius, trunc(locationSen[i,2]/20) + city_grid_radius], storm_time)
points <- rbind(points, point)
i <- i + 1
}
#data_tester <- cbind(locationSen, points)
#Run MlClassifier Once then will be able to predict for any pm values
try <- data_label(points, example[montht])
z <- priority_destinations(locationSen, try, airPref)
dataframeForStats <- data.frame(try, "x"=locationSen[,1], "y"=locationSen[,2])
bigData <- rbind(bigData, dataframeForStats)
updates <- nearest_sensor_finder(z, locationSen, airPref, try)
locationSen <- updates
datefromSQL <- datefromSQL + 60*60
storm_time <- sample(c(0,1), 1, prob = c(0.99, 0.01))
datecnt <- datecnt + 1
}
bigData <- rbind(bigData, dataframeForStats)
z
locationSen
airPref
try
destination <- z
sensors <- locationSem
sensors <- locationSen
quality_desired <- airPref
pm_class <- pm_data
pm_class <- try
#destination: final destination for sensor to move to
#sensors: data frame of all sensors in the network
#quality_desired: the type of air quality the client desires to know more about ("good" or "bad")(client-defined)
#pm_data: the classification of the particulate matter collected by each sensor
for(k in 1:length(destination[,1])){
print("k)")
print(k)
mobile_sensors <- sensors[which(sensors[,3]==1),]
num_mobiles <- length(mobile_sensors[,1])
dist_vec <- vector(length = num_mobiles)
for(i in 1:num_mobiles){
dist_vec[i] <- sqrt((destination[k,1] - mobile_sensors[i,1]) ^ 2 + (destination[k,2] - mobile_sensors[i,2]) ^ 2)
}
dist_vec <- unlist(dist_vec)
dist_vec[which(dist_vec == 0)] <- 15001
loop_iterate <- 1
nth_term <- 1
while(loop_iterate){
print("loopi")
print(loop_iterate)
loop_iterate <- 1
nth_term <- nth_term + 1
if(nth_term > length(dist_vec)){
break
}
near_mobile_index <- which(dist_vec == dist_vec[order(dist_vec)][nth_term])
near_mobile <- mobile_sensors[near_mobile_index,]
near_index <- which(sensors[,1] == near_mobile[1] & sensors[,2] == near_mobile[2])
if(near_mobile[4] == 1){
loop_iterate <- 2
k <- k + 1
} else if(pm_class[near_index, 4] == quality_desired){
loop_iterate <- 2
k <- k + 1
}
if(loop_iterate == 1){
movement <- move_sensor(dist_vec[near_mobile_index], destination[k,], sensors[near_index,])
movement <- unlist(movement)
if(movement[3]){
sensors[near_index,4] <- 1
}
sensors[near_index,1] <- movement[1] + sensors[near_index,1]
sensors[near_index,2] <- movement[2] + sensors[near_index, 2]
if(!movement[3]){
sensors[near_index,4] == 0
}
}
loop_iterate <- loop_iterate - 1
}
}
#destination: final destination for sensor to move to
#sensors: data frame of all sensors in the network
#quality_desired: the type of air quality the client desires to know more about ("good" or "bad")(client-defined)
#pm_data: the classification of the particulate matter collected by each sensor
for(k in 1:length(destination[,1])){
print("k)")
print(k)
mobile_sensors <- sensors[which(sensors[,3]==1),]
num_mobiles <- length(mobile_sensors[,1])
dist_vec <- vector(length = num_mobiles)
for(i in 1:num_mobiles){
dist_vec[i] <- sqrt((destination[k,1] - mobile_sensors[i,1]) ^ 2 + (destination[k,2] - mobile_sensors[i,2]) ^ 2)
}
dist_vec <- unlist(dist_vec)
dist_vec[which(dist_vec == 0)] <- 15001
loop_iterate <- 1
nth_term <- 1
while(loop_iterate){
print("loopk")
print(k)
loop_iterate <- 1
nth_term <- nth_term + 1
if(nth_term > length(dist_vec)){
break
}
near_mobile_index <- which(dist_vec == dist_vec[order(dist_vec)][nth_term])
near_mobile <- mobile_sensors[near_mobile_index,]
near_index <- which(sensors[,1] == near_mobile[1] & sensors[,2] == near_mobile[2])
if(near_mobile[4] == 1){
loop_iterate <- 2
k <- k + 1
} else if(pm_class[near_index, 4] == quality_desired){
loop_iterate <- 2
k <- k + 1
}
if(loop_iterate == 1){
movement <- move_sensor(dist_vec[near_mobile_index], destination[k,], sensors[near_index,])
movement <- unlist(movement)
if(movement[3]){
sensors[near_index,4] <- 1
}
sensors[near_index,1] <- movement[1] + sensors[near_index,1]
sensors[near_index,2] <- movement[2] + sensors[near_index, 2]
if(!movement[3]){
sensors[near_index,4] == 0
}
}
loop_iterate <- loop_iterate - 1
}
}
near_mobile_index
destination[k,]
