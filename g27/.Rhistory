df.next3 = df.test[col:(col+2)]
names(df.next3) = c(paste0("pm010",month), paste0("pm025",month), paste0("pm100",month))
df.noname = rbind(df.noname, df.next3)
col = col+3
}
df.noname[df.noname < 0] = NA   # mark negative values NA
df.noname = na.omit(df.noname)  # eventually omit NA
return(df.noname)
}
janyr.noname = next3rep(jan.test, "jan")  # fill rest of jan
febyr.noname = next3rep(feb.test, "feb")  # fill with feb
maryr.noname = next3rep(mar.test, "mar")  # fill with mar
apryr.noname = next3rep(apr.test, "apr")  # fill with apr
mayyr.noname = next3rep(may.test, "may")  # fill with may
junyr.noname = next3rep(jun.test, "jun")  # fill with jun
julyr.noname = next3rep(jul.test, "jul")  # fill with jul
augyr.noname = next3rep(aug.test, "aug")  # fill with aug
sepyr.noname = next3rep(sep.test, "sep")  # fill with sep
octyr.noname = next3rep(oct.test, "oct")  # fill with oct
novyr.noname = next3rep(nov.test, "nov")  # fill with nov
decyr.noname = next3rep(dec.test, "dec")  # fill with dec
outlierRemove <- function(yr.noname){
outliers1 = boxplot.stats(yr.noname[ ,1],coef = 3)$out
outliers2 = boxplot.stats(yr.noname[ ,2],coef = 3)$out
outliers3 = boxplot.stats(yr.noname[ ,3],coef = 3)$out
yr.nout = yr.noname[-which(yr.noname[ ,1] %in% outliers1), ]
yr.nout = yr.noname[-which(yr.noname[ ,2] %in% outliers2), ]
yr.nout = yr.noname[-which(yr.noname[ ,3] %in% outliers3), ]
rownames(yr.nout) = NULL
return(yr.nout)
}
jan.nout <- outlierRemove(janyr.noname)
janyr.noname
yr.noname <- janyr.noname
outliers1 = boxplot.stats(yr.noname[ ,1],coef = 3)$out
yr.noname[ ,1]
outliers1 = boxplot.stats(yr.noname[ ,1],coef = 3)$out
yr.noname[ ,1]
?transpose
outliers1 = boxplot.stats(transpose(yr.noname[ ,1]),coef = 3)$out
source('~/IE 332/IE332group27/g27/MLclassifierUpdate.R')
rm(list = ls())
#Load in all Kaggle Data for machine learning
january = as_tibble(fread("air-quality-data-from-extensive-network-of-sensors/january-2017.csv"))
february = as_tibble(fread("air-quality-data-from-extensive-network-of-sensors/february-2017.csv"))
march = as_tibble(fread("air-quality-data-from-extensive-network-of-sensors/march-2017.csv"))
april = as_tibble(fread("air-quality-data-from-extensive-network-of-sensors/april-2017.csv"))
may = as_tibble(fread("air-quality-data-from-extensive-network-of-sensors/may-2017.csv"))
june = as_tibble(fread("air-quality-data-from-extensive-network-of-sensors/june-2017.csv"))
july = as_tibble(fread("air-quality-data-from-extensive-network-of-sensors/july-2017.csv"))
august = as_tibble(fread("air-quality-data-from-extensive-network-of-sensors/august-2017.csv"))
september = as_tibble(fread("air-quality-data-from-extensive-network-of-sensors/september-2017.csv"))
october = as_tibble(fread("air-quality-data-from-extensive-network-of-sensors/october-2017.csv"))
november = as_tibble(fread("air-quality-data-from-extensive-network-of-sensors/november-2017.csv"))
december = as_tibble(fread("air-quality-data-from-extensive-network-of-sensors/december-2017.csv"))
Sys.setenv(TZ='Poland') #we're looking at data from Poland, to avoid erors we'll use this command. If this is not given a timezone error will appear.
#Convert time to a time that we can manipulate
january$`UTC time` = as_datetime(january$`UTC time`)
february$`UTC time` = as_datetime(february$`UTC time`)
march$`UTC time` = as_datetime(march$`UTC time`)
april$`UTC time` = as_datetime(april$`UTC time`)
may$`UTC time` = as_datetime(may$`UTC time`)
june$`UTC time` = as_datetime(june$`UTC time`)
july$`UTC time` = as_datetime(july$`UTC time`)
august$`UTC time` = as_datetime(august$`UTC time`)
september$`UTC time` = as_datetime(september$`UTC time`)
october$`UTC time` = as_datetime(october$`UTC time`)
november$`UTC time` = as_datetime(november$`UTC time`)
december$`UTC time` = as_datetime(december$`UTC time`)
jan.test = january %>% select(contains("pm"))
feb.test = february %>% select(contains("pm"))
mar.test = march %>% select(contains("pm"))
apr.test = april %>% select(contains("pm"))
may.test = may %>% select(contains("pm"))
jun.test = june %>% select(contains("pm"))
jul.test = july %>% select(contains("pm"))
aug.test = august %>% select(contains("pm"))
sep.test = september %>% select(contains("pm"))
oct.test = october %>% select(contains("pm"))
nov.test = november %>% select(contains("pm"))
dec.test = december %>% select(contains("pm"))
yr.noname = data.frame(   # to store 3 cols of all sensor data from all months
pm010 = jan.test$`3_pm1`,
pm025 = jan.test$`3_pm25`,
pm100 = jan.test$`3_pm10`
)
#function created to fill a data frame with all particulate data from Kaggle
#df.noname = Data frame of all pm values with no dates
#df.test= data from the respective month to load into dataframe
#col= the col that is desired to load into the matrix, default value is set to 1
next3rep = function(df.noname, df.test, col = 1){
while(col <= length(df.test)-2) {
df.next3 = df.test[col:(col+2)]
names(df.next3) = c("pm010", "pm025", "pm100")
df.noname = rbind(df.noname, df.next3)
col = col+3
}
return(df.noname)
}
yr.noname = next3rep(yr.noname, jan.test, col = 4)  # fill rest of jan
yr.noname = next3rep(yr.noname, feb.test)  # fill with feb
yr.noname = next3rep(yr.noname, mar.test)  # fill with mar
yr.noname = next3rep(yr.noname, apr.test)  # fill with apr
yr.noname = next3rep(yr.noname, may.test)  # fill with may
yr.noname = next3rep(yr.noname, jun.test)  # fill with jun
yr.noname = next3rep(yr.noname, jul.test)  # fill with jul
yr.noname = next3rep(yr.noname, aug.test)  # fill with aug
yr.noname = next3rep(yr.noname, sep.test)  # fill with sep
yr.noname = next3rep(yr.noname, oct.test)  # fill with oct
yr.noname = next3rep(yr.noname, nov.test)  # fill with nov
yr.noname = next3rep(yr.noname, dec.test)  # fill with dec
yr.noname[yr.noname < 0] = NA   # mark negative values NA
yr.noname = na.omit(yr.noname)  # eventually omit NA
# we need to remove outliers using interquartile range
outliers1 = boxplot.stats(yr.noname[ ,1],coef = 3)$out
outliers2 = boxplot.stats(yr.noname[ ,2],coef = 3)$out
outliers3 = boxplot.stats(yr.noname[ ,3],coef = 3)$out
yr.nout = yr.noname[-which(yr.noname[ ,1] %in% outliers1), ]
yr.nout = yr.noname[-which(yr.noname[ ,2] %in% outliers2), ]
yr.nout = yr.noname[-which(yr.noname[ ,3] %in% outliers3), ]
outliers1
yr.noname
rm(list = ls())
#Load in all Kaggle Data for machine learning
january = as_tibble(fread("air-quality-data-from-extensive-network-of-sensors/january-2017.csv"))
february = as_tibble(fread("air-quality-data-from-extensive-network-of-sensors/february-2017.csv"))
march = as_tibble(fread("air-quality-data-from-extensive-network-of-sensors/march-2017.csv"))
april = as_tibble(fread("air-quality-data-from-extensive-network-of-sensors/april-2017.csv"))
may = as_tibble(fread("air-quality-data-from-extensive-network-of-sensors/may-2017.csv"))
june = as_tibble(fread("air-quality-data-from-extensive-network-of-sensors/june-2017.csv"))
july = as_tibble(fread("air-quality-data-from-extensive-network-of-sensors/july-2017.csv"))
august = as_tibble(fread("air-quality-data-from-extensive-network-of-sensors/august-2017.csv"))
september = as_tibble(fread("air-quality-data-from-extensive-network-of-sensors/september-2017.csv"))
october = as_tibble(fread("air-quality-data-from-extensive-network-of-sensors/october-2017.csv"))
november = as_tibble(fread("air-quality-data-from-extensive-network-of-sensors/november-2017.csv"))
december = as_tibble(fread("air-quality-data-from-extensive-network-of-sensors/december-2017.csv"))
Sys.setenv(TZ='Poland') #we're looking at data from Poland, to avoid erors we'll use this command. If this is not given a timezone error will appear.
#Convert time to a time that we can manipulate
january$`UTC time` = as_datetime(january$`UTC time`)
february$`UTC time` = as_datetime(february$`UTC time`)
march$`UTC time` = as_datetime(march$`UTC time`)
april$`UTC time` = as_datetime(april$`UTC time`)
may$`UTC time` = as_datetime(may$`UTC time`)
june$`UTC time` = as_datetime(june$`UTC time`)
july$`UTC time` = as_datetime(july$`UTC time`)
august$`UTC time` = as_datetime(august$`UTC time`)
september$`UTC time` = as_datetime(september$`UTC time`)
october$`UTC time` = as_datetime(october$`UTC time`)
november$`UTC time` = as_datetime(november$`UTC time`)
december$`UTC time` = as_datetime(december$`UTC time`)
jan.test = january %>% select(contains("pm"))
feb.test = february %>% select(contains("pm"))
mar.test = march %>% select(contains("pm"))
apr.test = april %>% select(contains("pm"))
may.test = may %>% select(contains("pm"))
jun.test = june %>% select(contains("pm"))
jul.test = july %>% select(contains("pm"))
aug.test = august %>% select(contains("pm"))
sep.test = september %>% select(contains("pm"))
oct.test = october %>% select(contains("pm"))
nov.test = november %>% select(contains("pm"))
dec.test = december %>% select(contains("pm"))
#function created to fill a data frame with all particulate data from Kaggle
#df.noname = Data frame of all pm values with no dates
#df.test= data from the respective month to load into dataframe
#col= the col that is desired to load into the matrix, default value is set to 1
next3rep = function(df.test, month){
col = 1
df.noname = NULL
while(col <= length(df.test)-2) {
df.next3 = df.test[col:(col+2)]
names(df.next3) = c(paste0("pm010",month), paste0("pm025",month), paste0("pm100",month))
df.noname = rbind(df.noname, df.next3)
col = col+3
}
df.noname[df.noname < 0] = NA   # mark negative values NA
df.noname = na.omit(df.noname)  # eventually omit NA
return(df.noname)
}
janyr.noname = next3rep(jan.test, "jan")  # fill rest of jan
febyr.noname = next3rep(feb.test, "feb")  # fill with feb
maryr.noname = next3rep(mar.test, "mar")  # fill with mar
apryr.noname = next3rep(apr.test, "apr")  # fill with apr
mayyr.noname = next3rep(may.test, "may")  # fill with may
junyr.noname = next3rep(jun.test, "jun")  # fill with jun
julyr.noname = next3rep(jul.test, "jul")  # fill with jul
augyr.noname = next3rep(aug.test, "aug")  # fill with aug
sepyr.noname = next3rep(sep.test, "sep")  # fill with sep
octyr.noname = next3rep(oct.test, "oct")  # fill with oct
novyr.noname = next3rep(nov.test, "nov")  # fill with nov
decyr.noname = next3rep(dec.test, "dec")  # fill with dec
yr.noname <- cbind(janyr.noname, febyr.noname, maryr.noname, aprilyr.noname, mayyr.noname, junyr.noname, julyr.noname, augyr.noname, sepyr.noname, octyr.noname, novyr.noname, decyr.noname)
yr.noname <- cbind(janyr.noname, febyr.noname, maryr.noname, apryr.noname, mayyr.noname, junyr.noname, julyr.noname, augyr.noname, sepyr.noname, octyr.noname, novyr.noname, decyr.noname)
?sample
n <- min(count(janyr.noname))
n
count(janyr.noname)
dim(janyr.noname)[1]
n <- min(dim(janyr.noname)[1], dim(febyr.noname)[1], dim(maryr.noname)[1], dim(aprilyr.noname)[1], dim(mayyr.noname)[1], dim(junyr.noname)[1], dim(julyyr.noname)[1], dim(augyr.noname)[1], dim(sepyr.noname)[1], dim(octyr.noname)[1], dim(novyr.noname)[1], dim(decyr.noname)[1])
n <- min(dim(janyr.noname)[1], dim(febyr.noname)[1], dim(maryr.noname)[1], dim(apryr.noname)[1], dim(mayyr.noname)[1], dim(junyr.noname)[1], dim(julyyr.noname)[1], dim(augyr.noname)[1], dim(sepyr.noname)[1], dim(octyr.noname)[1], dim(novyr.noname)[1], dim(decyr.noname)[1])
n <- min(dim(janyr.noname)[1], dim(febyr.noname)[1], dim(maryr.noname)[1], dim(apryr.noname)[1], dim(mayyr.noname)[1], dim(junyr.noname)[1], dim(julyr.noname)[1], dim(augyr.noname)[1], dim(sepyr.noname)[1], dim(octyr.noname)[1], dim(novyr.noname)[1], dim(decyr.noname)[1])
n
yr.noname <- cbind(sample(janyr.noname, n),  sample(febyr.noname, n), sample(maryr.noname, n), sample(apryr.noname,n),  sample(mayyr.noname,n), sample(junyr.noname, n), sample(julyr.noname, n), sample(augyr.noname,n), sample(sepyr.noname, n), sample(octyr.noname, sample(novyr.noname, n) sample(decyr.noname, n))
# we need to remove outliers using interquartile range
outlierRemove <- function(yr.noname){
outliers1 = boxplot.stats((yr.noname[ ,1]),coef = 3)$out
outliers2 = boxplot.stats(yr.noname[ ,2],coef = 3)$out
outliers3 = boxplot.stats(yr.noname[ ,3],coef = 3)$out
yr.nout = yr.noname[-which(yr.noname[ ,1] %in% outliers1), ]
yr.nout = yr.noname[-which(yr.noname[ ,2] %in% outliers2), ]
yr.nout = yr.noname[-which(yr.noname[ ,3] %in% outliers3), ]
rownames(yr.nout) = NULL
return(yr.nout)
}
jan.nout <- outlierRemove(janyr.noname)
yr.nout = data.frame
# statistics
yr.avg_pm010 = mean(yr.nout$pm010)
yr.avg_pm025 = mean(yr.nout$pm025)
yr.avg_pm100 = mean(yr.nout$pm100)
# preparing factors for training based on means after outliers removed, per pm level
yr.nout$pm010.label = as.factor(ifelse(yr.nout$pm010 >= yr.avg_pm010, 1, 0))
yr.nout$pm025.label = as.factor(ifelse(yr.nout$pm025 >= yr.avg_pm025, 1, 0))
yr.nout$pm100.label = as.factor(ifelse(yr.nout$pm100 >= yr.avg_pm100, 1, 0))
yr.nout$rating = as.numeric(as.character(yr.nout[,4])) + as.numeric(as.character(yr.nout[,5])) + as.numeric(as.character(yr.nout[,6]))  # row-sum of pm factors
yr.nout$rating = factor(yr.nout$rating) # back to factor with Levels: {0, 1, 2, 3} in order of 'best' to 'worst'
#Do the classify procedure as labeled in A2
trainIndex = createDataPartition(yr.nout$rating, p=0.75)$Resample1
train = yr.nout[trainIndex, ]
test = yr.nout[-trainIndex, ]
yr.nB = naiveBayes(rating ~ pm010 + pm025 + pm100, data=train) # uses *.label cols
yr.trainPred = predict(yr.nB, newdata = train)
yr.trainTable = table(train$rating, yr.trainPred)
yr.testPred = predict(yr.nB, newdata = test[1:3])
yr.testTable = table(test$rating, yr.testPred)
confusionMatrix(yr.testPred, test$rating)$overall['Accuracy']
return(yr.nB)
}
#After running the confusion matrix our predicter has 87.37% accuracy!
#We can now just input generated pm values and get labels automatically
#Function made to take in new data points that are able to classify simulated data
#pm_data = generated partiulate matter dataframe
#nB= inputed naive Bayes classifier generated from the Kaggle data using machine learning
data_label <- function(pm_data, nB){
testdata = predict(nB, newdata = pm_data)
combined= cbind(pm_data, testdata)
return(combined)
}
yr.noname <- cbind(sample(janyr.noname, n), sample(febyr.noname, n), sample(maryr.noname, n), sample(apryr.noname,n),  sample(mayyr.noname,n), sample(junyr.noname, n), sample(julyr.noname, n), sample(augyr.noname,n), sample(sepyr.noname, n), sample(octyr.noname, n), sample(novyr.noname, n), sample(decyr.noname, n))
n <- min(dim(janyr.noname)[1], dim(febyr.noname)[1], dim(maryr.noname)[1], dim(apryr.noname)[1], dim(mayyr.noname)[1], dim(junyr.noname)[1], dim(julyr.noname)[1], dim(augyr.noname)[1], dim(sepyr.noname)[1], dim(octyr.noname)[1], dim(novyr.noname)[1], dim(decyr.noname)[1])
n
yr.noname <- cbind(sample(janyr.noname, n), sample(febyr.noname, n), sample(maryr.noname, n), sample(apryr.noname,n),  sample(mayyr.noname,n), sample(junyr.noname, n), sample(julyr.noname, n), sample(augyr.noname,n), sample(sepyr.noname, n), sample(octyr.noname, n), sample(novyr.noname, n), sample(decyr.noname, n))
yr.noname <- cbind(sample(janyr.noname, n), sample(febyr.noname, n), sample(maryr.noname, n), sample(apryr.noname,n),  sample(mayyr.noname,n), sample(junyr.noname, n), sample(julyr.noname, n), sample(augyr.noname,n), sample(sepyr.noname, n), sample(octyr.noname, n), sample(novyr.noname, n), sample(decyr.noname, n))
length(janyr.noname)
sample(janyr.noname[, 1:3], n)
janyr.noname[1:n]
janyr.noname[1:n,]
n <- min(dim(janyr.noname)[1], dim(febyr.noname)[1], dim(maryr.noname)[1], dim(apryr.noname)[1], dim(mayyr.noname)[1], dim(junyr.noname)[1], dim(julyr.noname)[1], dim(augyr.noname)[1], dim(sepyr.noname)[1], dim(octyr.noname)[1], dim(novyr.noname)[1], dim(decyr.noname)[1])
n
sample(febyr.noname[1:n,], n)
sample(dim(febyr.noname)[1], n)
febyr.noname[sample(dim(febyr.noname)[1], n)]
sample(dim(febyr.noname)[1], n)
febyr.noname[sample(dim(febyr.noname)[1], n),]
#randomly selects days for each month to then us for classifying the data
yr.noname <- cbind(febyr.noname[sample(dim(febyr.noname)[1], n),], febyr.noname[sample(dim(febyr.noname)[1], n),], febyr.noname[sample(dim(febyr.noname)[1], n),], febyr.noname[sample(dim(febyr.noname)[1], n),], febyr.noname[sample(dim(febyr.noname)[1], n),], febyr.noname[sample(dim(febyr.noname)[1], n),], febyr.noname[sample(dim(febyr.noname)[1], n),], febyr.noname[sample(dim(febyr.noname)[1], n),], febyr.noname[sample(dim(febyr.noname)[1], n),], febyr.noname[sample(dim(febyr.noname)[1], n),], febyr.noname[sample(dim(febyr.noname)[1], n),], febyr.noname[sample(dim(febyr.noname)[1], n),])
yr.noname
#randomly selects days for each month to then us for classifying the data
yr.noname <- cbind(janyr.noname[sample(dim(janyr.noname)[1], n),], febyr.noname[sample(dim(febyr.noname)[1], n),], maryr.noname[sample(dim(maryr.noname)[1], n),], apryr.noname[sample(dim(apryr.noname)[1], n),], mayyr.noname[sample(dim(mayyr.noname)[1], n),], junyr.noname[sample(dim(junyr.noname)[1], n),], julyr.noname[sample(dim(julyr.noname)[1], n),], augyr.noname[sample(dim(augyr.noname)[1], n),], sepyr.noname[sample(dim(sepyr.noname)[1], n),], octyr.noname[sample(dim(octyr.noname)[1], n),], novyr.noname[sample(dim(novyr.noname)[1], n),], decyr.noname[sample(dim(decyr.noname)[1], n),])
yr.noname
# we need to remove outliers using interquartile range
for (cnt in 1:dim(yr.noname)[2]){
outliers1 = boxplot.stats((yr.noname[ ,cnt]),coef = 3)$out
yr.nout = yr.noname[-which(yr.noname[ ,cnt] %in% outliers1), ]
}
yr.nout
yr.noname
yr.nout$paste0(pm010.label,month)
yr.nout$paste0(pm010,month)
yr.nout$paste0("pm010",month)
month = "jan"
yr.nout$paste0("pm010",month)
yr.nout[paste0("pm010",month)]
# statistics
yr.avg_pm010 = mean(yr.nout[paste0(pm010,month)])
# statistics
yr.avg_pm010 = mean(yr.nout[paste0("pm010",month)])
yr.nout
month = "jan"
yr.nout[paste0("pm010",month)]
mean(yr.nout[paste0("pm010",month)])
anyNA(yr.nout)
mean(yr.nout[paste0("pm010",month)])
yr.nout[paste0("pm010",month)]
yr.nout
yr.nout[contains("jan")]
contains("jan")
yr.nout %>% select(contains("jan"))
jan.nB =nBbymonth(yr.nout %>% select(contains("jan")))
source('~/IE 332/IE332group27/g27/MLclassifierUpdate.R')
jan.nB =nBbymonth(yr.nout %>% select(contains("jan")))
nBbymonth <- function(yr.nout){
colnames(yr.nout) = c("pm010", "pm025", "pm100")
yr.avg_pm010 = mean(yr.nout$pm010)
yr.avg_pm025 = mean(yr.nout$pm025)
yr.avg_pm100 = mean(yr.nout$pm100)
# preparing factors for training based on means after outliers removed, per pm level
yr.nout$pm010.label = as.factor(ifelse(yr.nout$pm010 >= yr.avg_pm010, 1, 0))
yr.nout$pm025.label = as.factor(ifelse(yr.nout$pm025 >= yr.avg_pm025, 1, 0))
yr.nout$pm100.label = as.factor(ifelse(yr.nout$pm100 >= yr.avg_pm100, 1, 0))
yr.nout$rating = as.numeric(as.character(yr.nout[,4])) + as.numeric(as.character(yr.nout[,5])) + as.numeric(as.character(yr.nout[,6]))  # row-sum of pm factors
yr.nout$rating = factor(yr.nout$rating) # back to factor with Levels: {0, 1, 2, 3} in order of 'best' to 'worst'
#Do the classify procedure as labeled in A2
trainIndex = createDataPartition(yr.nout$rating, p=0.75)$Resample1
train = yr.nout[trainIndex, ]
test = yr.nout[-trainIndex, ]
yr.nB = naiveBayes(rating ~ pm010 + pm025 + pm100, data=train) # uses *.label cols
yr.trainPred = predict(yr.nB, newdata = train)
yr.trainTable = table(train$rating, yr.trainPred)
yr.testPred = predict(yr.nB, newdata = test[1:3])
yr.testTable = table(test$rating, yr.testPred)
confusionMatrix(yr.testPred, test$rating)$overall['Accuracy']
return(yr.nB)
}
jan.nB =nBbymonth(yr.nout %>% select(contains("jan")))
jan.nB
jan.nB =nBbymonth(yr.nout %>% select(contains("jan")))
nBbymonth <- function(yr.nout){
colnames(yr.nout) = c("pm010", "pm025", "pm100")
yr.avg_pm010 = mean(yr.nout$pm010)
yr.avg_pm025 = mean(yr.nout$pm025)
yr.avg_pm100 = mean(yr.nout$pm100)
# preparing factors for training based on means after outliers removed, per pm level
yr.nout$pm010.label = as.factor(ifelse(yr.nout$pm010 >= yr.avg_pm010, 1, 0))
yr.nout$pm025.label = as.factor(ifelse(yr.nout$pm025 >= yr.avg_pm025, 1, 0))
yr.nout$pm100.label = as.factor(ifelse(yr.nout$pm100 >= yr.avg_pm100, 1, 0))
yr.nout$rating = as.numeric(as.character(yr.nout[,4])) + as.numeric(as.character(yr.nout[,5])) + as.numeric(as.character(yr.nout[,6]))  # row-sum of pm factors
yr.nout$rating = factor(yr.nout$rating) # back to factor with Levels: {0, 1, 2, 3} in order of 'best' to 'worst'
#Do the classify procedure as labeled in A2
trainIndex = createDataPartition(yr.nout$rating, p=0.75)$Resample1
train = yr.nout[trainIndex, ]
test = yr.nout[-trainIndex, ]
yr.nB = naiveBayes(rating ~ pm010 + pm025 + pm100, data=train) # uses *.label cols
yr.trainPred = predict(yr.nB, newdata = train)
yr.trainTable = table(train$rating, yr.trainPred)
yr.testPred = predict(yr.nB, newdata = test[1:3])
yr.testTable = table(test$rating, yr.testPred)
print(confusionMatrix(yr.testPred, test$rating)$overall['Accuracy'])
return(yr.nB)
}
jan.nB =nBbymonth(yr.nout %>% select(contains("jan")))
jan.nB
cityGrid <- buildCity(3)
source('~/IE 332/IE332group27/g27/buildCity.R')
cityGrid <- buildCity(3)
cityGrid <- buildCity(3)
cityGrid <- buildCity(3)
cityGrid <- buildCity(1)
jan.nB =nBbymonth(yr.nout %>% select(contains("jan")))
feb.nB =nBbymonth(yr.nout %>% select(contains("feb")))
mar.nB =nBbymonth(yr.nout %>% select(contains("mar")))
apr.nB =nBbymonth(yr.nout %>% select(contains("apr")))
may.nB =nBbymonth(yr.nout %>% select(contains("may")))
jun.nB =nBbymonth(yr.nout %>% select(contains("jun")))
jul.nB =nBbymonth(yr.nout %>% select(contains("jul")))
aug.nB =nBbymonth(yr.nout %>% select(contains("aug")))
sep.nB =nBbymonth(yr.nout %>% select(contains("sep")))
oct.nB =nBbymonth(yr.nout %>% select(contains("oct")))
nov.nB =nBbymonth(yr.nout %>% select(contains("nov")))
dec.nB =nBbymonth(yr.nout %>% select(contains("dec")))
all.nBs = list(jan.nB, feb.nB, mar.nB)
all.nBs
all.nBs = list("jan" = jan.nB, "feb" = feb.nB, "mar" = mar.nB)
all.nBs$
jan
datefromSQL <- as.POSIXlt("2019-05-06 20:51:50 CET")
format(datefromSQL,"%B")
datefromSQL <- as.POSIXlt("2019-03-06 20:51:50 CET")
format(datefromSQL,"%B")
all.nBs = list("January" = jan.nB, "February" = feb.nB, "March" = mar.nB, "April"=apr.nB, "May"=may.nB, "June"=june.nB, "July"=july.nB, "August"=aug.nB, "September"=sep.nB, "October"=oct.nB, "November"=nov.nB, "December" =dec.nB)
all.nBs = list("January" = jan.nB, "February" = feb.nB, "March" = mar.nB, "April"=apr.nB, "May"=may.nB, "June"=jun.nB, "July"=july.nB, "August"=aug.nB, "September"=sep.nB, "October"=oct.nB, "November"=nov.nB, "December" =dec.nB)
jan.nB =nBbymonth(yr.nout %>% select(contains("jan")))
all.nBs = list("January" = jan.nB, "February" = feb.nB, "March" = mar.nB, "April"=apr.nB, "May"=may.nB, "June"=jun.nB, "July"=jul.nB, "August"=aug.nB, "September"=sep.nB, "October"=oct.nB, "November"=nov.nB, "December" =dec.nB)
#Function made to take in new data points that are able to classify simulated data
#pm_data = generated partiulate matter dataframe
#nB= inputed naive Bayes classifier generated from the Kaggle data using machine learning
data_label <- function(pm_data, nB){
testdata = predict(nB, newdata = pm_data)
combined= cbind(pm_data, testdata)
return(combined)
}
#initialization
budget <- 300000
cityGrid <- buildCity(1)
city_grid_radius <- 750
rm(list = ls())
for(y in 1:1500){
if(cityGrid[x,y] != -1){
cityGrid[x,y]<-2
}
}
source('~/IE 332/IE332group27/g27/buildCity.R')
source('~/IE 332/IE332group27/g27/randomCollect.R')
source('~/IE 332/IE332group27/g27/OptimizationProblem.R')
source('~/IE 332/IE332group27/g27/move_mobile.R')
source('~/IE 332/IE332group27/g27/MLclassifierUpdate.R')
source('~/IE 332/IE332group27/g27/sortPMtest.R')
#initialization
budget <- 300000
cityGrid <- buildCity(1)
city_grid_radius <- 750
MappedNetwork<- SA(budget, cityGrid, just_values = F)
example <- MlClassifier()
#Generated Pm Values
locationSen <- MappedNetwork$best
timefromSQL <- 1
datefromSQL <- as.POSIXlt("2019-03-06 20:51:50 CET")
month <- format(datefromSQL,"%B")
points <- NULL
point <- NULL
dataframeForStates <- NULL
bigData <- NULL
datecnt <- 1
OGmap <- locationSen
while (i <= dim(locationSen)[1]){
#print(i)
point <- sortPM(datefromSQL, cityGrid[trunc(locationSen[i,1]/20) + city_grid_radius, trunc(locationSen[i,2]/20) + city_grid_radius])
points <- rbind(points, point)
i <- i + 1
}
i = 1
while (i <= dim(locationSen)[1]){
#print(i)
point <- sortPM(datefromSQL, cityGrid[trunc(locationSen[i,1]/20) + city_grid_radius, trunc(locationSen[i,2]/20) + city_grid_radius])
points <- rbind(points, point)
i <- i + 1
}
source('~/IE 332/IE332group27/g27/smoothing_reg_month_maker.R')
while (i <= dim(locationSen)[1]){
#print(i)
point <- sortPM(datefromSQL, cityGrid[trunc(locationSen[i,1]/20) + city_grid_radius, trunc(locationSen[i,2]/20) + city_grid_radius])
points <- rbind(points, point)
i <- i + 1
}
#data_tester <- cbind(locationSen, points)
#Run MlClassifier Once then will be able to predict for any pm values
try <- data_label(points, example)
montht <- format(datefromSQL,"%B")
#data_tester <- cbind(locationSen, points)
#Run MlClassifier Once then will be able to predict for any pm values
try <- data_label(points, example$montht)
#data_tester <- cbind(locationSen, points)
#Run MlClassifier Once then will be able to predict for any pm values
try <- data_label(points, example[month])
try
source('~/IE 332/IE332group27/g27/MLclassifierUpdate.R')
i = 1
print(datecnt)
while (i <= dim(locationSen)[1]){
#print(i)
point <- sortPM(datefromSQL, cityGrid[trunc(locationSen[i,1]/20) + city_grid_radius, trunc(locationSen[i,2]/20) + city_grid_radius])
points <- rbind(points, point)
i <- i + 1
}
#data_tester <- cbind(locationSen, points)
#Run MlClassifier Once then will be able to predict for any pm values
try <- data_label(points, example[month])
z <- priority_destinations(locationSen, try)
#data_tester <- cbind(locationSen, points)
#Run MlClassifier Once then will be able to predict for any pm values
try <- data_label(points, example[month])
try
datefromSQL <- as.POSIXlt("2019-05-06 20:51:50 CET")
MappedNetwork<- SA(budget, cityGrid, just_values = F)
timefromSQL <- 1
datefromSQL <- as.POSIXlt("2019-05-06 20:51:50 CET")
montht <- format(datefromSQL,"%B")
points <- NULL
point <- NULL
dataframeForStates <- NULL
bigData <- NULL
datecnt <- 1
OGmap <- locationSen
points <- NULL
point <- NULL
dataframeForStats <- NULL
i = 1
print(datecnt)
while (i <= dim(locationSen)[1]){
#print(i)
point <- sortPM(datefromSQL, cityGrid[trunc(locationSen[i,1]/20) + city_grid_radius, trunc(locationSen[i,2]/20) + city_grid_radius])
points <- rbind(points, point)
i <- i + 1
}
#data_tester <- cbind(locationSen, points)
#Run MlClassifier Once then will be able to predict for any pm values
try <- data_label(points, example[month])
try
par(mfrow=c(1,1))
cityGrid <- buildCity(1)
cityGrid <- buildCity(1)
source('~/IE 332/IE332group27/g27/buildCity.R')
cityGrid <- buildCity(1)
par(mfrow = c(3, 2))
par(mfrow = c(1, 1))
cityGrid <- buildCity(1)
par(mar = c(0, 0, 0, 0))
cityGrid <- buildCity(2)
par(mar = c(0, 0, 0, 0))
cityGrid <- buildCity(3)
cityGrid <- buildCity(4)
cityGrid <- buildCity(1)
